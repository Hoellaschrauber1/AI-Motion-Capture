<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Motion Capture mit 3D-Vorschau</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

    <!-- Libraries for 3D Preview & Export -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .input_video { display: none; }
        .output_canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.75rem;
        }
        #preview-container canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0.75rem;
        }
        .loader {
            border: 8px solid #f3f3f3;
            border-radius: 50%;
            border-top: 8px solid #3B82F6;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            color: white;
            transition: background-color 0.2s;
            cursor: pointer;
            border: none;
        }
        .btn-green { background-color: #10B981; }
        .btn-green:hover { background-color: #059669; }
        .btn-red { background-color: #EF4444; }
        .btn-red:hover { background-color: #DC2626; }
        .btn-blue { background-color: #3B82F6; }
        .btn-blue:hover { background-color: #2563EB; }
        .btn:disabled { background-color: #6B7280; cursor: not-allowed; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4 overflow-hidden">

    <div class="w-full max-w-7xl mx-auto flex flex-col">
        <div class="text-center mb-4">
            <h1 class="text-3xl md:text-4xl font-bold">AI Motion Capture mit 3D-Vorschau</h1>
            <p id="status-text" class="text-gray-400 mt-1">Bitte erlauben Sie den Zugriff auf die Webcam.</p>
        </div>

        <!-- Main Content Area -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 flex-grow">
            <!-- Left Panel: Camera View -->
            <div class="relative w-full aspect-video bg-gray-800 rounded-xl flex items-center justify-center">
                <div id="loading-spinner" class="loader"></div>
                <video class="input_video"></video>
                <canvas class="output_canvas absolute top-0 left-0"></canvas>
            </div>
            <!-- Right Panel: 3D Preview -->
            <div id="preview-container" class="relative w-full aspect-video bg-gray-800 rounded-xl">
                 <div id="preview-text" class="absolute inset-0 flex items-center justify-center text-gray-400">3D-Vorschau wird geladen...</div>
            </div>
        </div>
        
        <!-- Control Buttons -->
        <div class="flex justify-center items-center space-x-4 mt-4">
            <button id="startButton" class="btn btn-green">Aufnahme starten</button>
            <button id="stopButton" class="btn btn-red" style="display: none;">Aufnahme beenden</button>
            <button id="downloadButton" class="btn btn-blue" style="display: none;">ZIP herunterladen</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // === UI & STATE MANAGEMENT ===
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const loadingSpinner = document.getElementById('loading-spinner');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusText = document.getElementById('status-text');
        const previewContainer = document.getElementById('preview-container');
        const previewText = document.getElementById('preview-text');

        let isRecording = false;
        let recordedFrames = [];
        let lastFrameTime = 0;
        let zipBlob = null;

        // === 3D PREVIEW SETUP ===
        // 'camera' is for the three.js scene. The webcam camera will be named differently.
        let scene, camera, renderer, controls, skeletonHelper;
        const bones = [];
        const boneMap = {};

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // bg-gray-800

            // Camera
            camera = new THREE.PerspectiveCamera(75, previewContainer.clientWidth / previewContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            previewContainer.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Ground
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);

            // Create a basic skeleton structure
            for (let i = 0; i < 33; i++) {
                const bone = new THREE.Bone();
                bone.name = `bone_${i}`;
                bones.push(bone);
                boneMap[i] = bone;
            }
            
            // Simple hierarchy based on POSE_CONNECTIONS
            POSE_CONNECTIONS.forEach(conn => {
                const parent = boneMap[conn[0]];
                const child = boneMap[conn[1]];
                // Avoid cycles and re-parenting to keep it simple
                if (child && parent && !child.parent && child !== parent) {
                   parent.add(child);
                }
            });
            // Add the first bone (nose) as the root if it has no parent
            if (bones.length > 0 && !bones[0].parent) {
                scene.add(bones[0]);
            }


            skeletonHelper = new THREE.SkeletonHelper(scene);
            skeletonHelper.visible = true;
            scene.add(skeletonHelper);
            
            previewText.style.display = 'none';

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = previewContainer.clientWidth / previewContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(previewContainer.clientWidth, previewContainer.clientHeight);
            }
        });

        // === EVENT LISTENERS ===
        startButton.onclick = () => {
            isRecording = true;
            recordedFrames = [];
            zipBlob = null;
            lastFrameTime = performance.now();
            
            startButton.style.display = 'none';
            stopButton.style.display = 'inline-block';
            downloadButton.style.display = 'none';
            statusText.textContent = '🔴 Aufnahme läuft...';
        };

        stopButton.onclick = () => {
            isRecording = false;
            stopButton.style.display = 'none';
            statusText.textContent = '🔄 Verarbeitung der Animation... Bitte warten.';
            stopButton.disabled = true;

            setTimeout(() => {
                processAndCreateZip(recordedFrames);
                startButton.style.display = 'inline-block';
                startButton.disabled = false;
                stopButton.disabled = false;
            }, 100);
        };

        downloadButton.onclick = () => {
            if (zipBlob) {
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'motion-capture.zip';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }
        };

        // === MEDIAPIPE & CAMERA SETUP ===
        function onResults(results) {
            if (loadingSpinner.style.display !== 'none') {
                loadingSpinner.style.display = 'none';
                statusText.textContent = 'Kamera bereit. Starten Sie die Aufnahme.';
                initThree();
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#34D399', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#F87171', lineWidth: 2, radius: 5});
            }
            canvasCtx.restore();

            if (results.poseWorldLandmarks && bones.length > 0) {
                // Update 3D skeleton in preview
                results.poseWorldLandmarks.forEach((landmark, i) => {
                    const bone = bones[i];
                    if (bone) {
                        // Center the model and adjust coordinates for Three.js
                        bone.position.set(
                            -landmark.x,
                            -landmark.y + 1.5, // Center model vertically
                            -landmark.z
                        );
                    }
                });

                if (isRecording) {
                    const now = performance.now();
                    const timeDelta = (now - lastFrameTime) / 1000.0;
                    lastFrameTime = now;
                    const landmarksCopy = JSON.parse(JSON.stringify(results.poseWorldLandmarks));
                    recordedFrames.push({ landmarks: landmarksCopy, time: timeDelta });
                }
            }
        }

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);

        // Renamed to avoid conflict with the three.js camera
        const mediaPipeCamera = new Camera(videoElement, {
            onFrame: async () => await pose.send({image: videoElement}),
            width: 1280,
            height: 720
        });
        mediaPipeCamera.start();

        // === 3D EXPORT LOGIC (Similar to before) ===
        async function processAndCreateZip(frames) {
            if (frames.length === 0) {
                statusText.textContent = 'Keine Daten aufgenommen. Bitte versuchen Sie es erneut.';
                return;
            }

            const exportScene = new THREE.Scene();
            const exportBones = [];
            const exportBoneMap = {};
            
            for (let i = 0; i < 33; i++) {
                const bone = new THREE.Bone();
                bone.name = `bone_${i}`;
                exportBones.push(bone);
                exportBoneMap[i] = bone;
            }
            POSE_CONNECTIONS.forEach(conn => {
                const parent = exportBoneMap[conn[0]];
                const child = exportBoneMap[conn[1]];
                if (parent && child && child.parent === null) {
                    parent.add(child);
                }
            });
            
            const skeleton = new THREE.Skeleton(exportBones);
            const tracks = [];
            skeleton.bones.forEach((bone, index) => {
                const landmarkIndex = parseInt(bone.name.replace('bone_', ''));
                const positionKF = new THREE.VectorKeyframeTrack(
                    `.bones[${index}].position`, [], []
                );
                tracks.push(positionKF);
            });

            let currentTime = 0;
            frames.forEach(frame => {
                currentTime += frame.time;
                tracks.forEach((track, trackIndex) => {
                    const bone = skeleton.bones[trackIndex];
                    const landmarkIndex = parseInt(bone.name.replace('bone_', ''));
                    const landmark = frame.landmarks[landmarkIndex];
                    if (landmark) {
                        track.times.push(currentTime);
                        // Using the same coordinate transformation as the preview
                        track.values.push(-landmark.x, -landmark.y + 1.5, -landmark.z);
                    }
                });
            });

            const clip = new THREE.AnimationClip('PoseAnimation', -1, tracks);
            const geometry = new THREE.BoxGeometry(0.01, 0.01, 0.01);
            const material = new THREE.MeshBasicMaterial();
            const mesh = new THREE.SkinnedMesh(geometry, material);
            
            mesh.add(skeleton.bones[0]);
            mesh.bind(skeleton);
            exportScene.add(mesh);
            
            const exporter = new GLTFExporter();
            exporter.parse(
                exportScene,
                (gltf) => {
                    const glb = new Blob([gltf], { type: 'application/octet-stream' });
                    const zip = new JSZip();
                    zip.file("animation.glb", glb);
                    zip.file("readme.txt", "Import animation.glb into Blender or another 3D viewer.\n\nCreated with AI Motion Capture App.");
                    zip.generateAsync({ type: "blob" }).then(content => {
                        zipBlob = content;
                        statusText.textContent = '✅ Verarbeitung abgeschlossen! Bereit zum Herunterladen.';
                        downloadButton.style.display = 'inline-block';
                    });
                },
                (error) => { 
                    console.error('An error happened during GLTF export:', error); 
                    statusText.textContent = '❌ Fehler beim Exportieren der Animation.';
                },
                { binary: true, animations: [clip] }
            );
        }
    </script>
</body>
</html>
