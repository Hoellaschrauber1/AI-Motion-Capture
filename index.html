<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KI Motion Capture App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 8px solid #f3f3f3;
            border-radius: 50%;
            border-top: 8px solid #3498db;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .dot {
            height: 12px;
            width: 12px;
            background-color: #f87171;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* NEU: Responsive Stile für mobile Geräte */
        #video-container {
            width: 100%;
            max-height: 75vh; /* Verhindert, dass das Video auf hohen Bildschirmen zu groß wird */
            background-color: #000;
        }

        #webcam, #output-canvas {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Stellt sicher, dass das gesamte Video sichtbar ist */
        }

        /* Passt die Größe der Steuerelemente auf kleinen Bildschirmen an */
        @media (max-width: 640px) {
            #controls-container button {
                padding: 0.75rem 1rem;
                font-size: 0.875rem;
            }
            #exit-fullscreen-btn {
                font-size: 0.875rem;
                padding: 0.5rem 0.75rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div id="app-container" class="w-full max-w-4xl mx-auto flex flex-col items-center">
        <h1 class="text-3xl md:text-4xl font-bold mb-2 text-center">KI Motion Capture</h1>
        <p id="status" class="text-blue-300 mb-4 h-6 text-center">Initialisiere Kamera...</p>

        <!-- Ladeanzeige -->
        <div id="loader-container" class="w-full bg-gray-800 rounded-lg flex items-center justify-center" style="aspect-ratio: 16/9; max-height: 75vh;">
            <div class="text-center">
                <div class="loader mx-auto"></div>
                <p class="mt-4 text-lg">KI-Modell wird geladen...</p>
            </div>
        </div>
        
        <!-- Video und Canvas Container -->
        <div id="video-container" class="relative w-full rounded-lg overflow-hidden shadow-2xl hidden">
            <video id="webcam" class="absolute top-0 left-0" playsinline></video>
            <canvas id="output-canvas" class="absolute top-0 left-0"></canvas>
            <button id="exit-fullscreen-btn" class="absolute top-4 right-4 bg-black/50 hover:bg-black/75 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300 hidden z-50">
                Vollbild Beenden
            </button>
        </div>

        <!-- Steuerungselemente -->
        <div id="controls-container" class="flex flex-wrap items-center justify-center gap-4 mt-6">
            <button id="record-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 flex items-center gap-2 disabled:bg-gray-500 disabled:cursor-not-allowed">
                <span id="record-icon" class="w-3 h-3 bg-white rounded-full"></span>
                <span id="record-text">Aufnehmen</span>
            </button>
            <button id="stop-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>
                Beenden & Exportieren
            </button>
            <button id="fullscreen-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300">
                Vollbild
            </button>
        </div>
    </div>

    <!-- Einbinden der Bibliotheken -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script type="module">
        // DOM-Elemente abrufen
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const recordBtn = document.getElementById('record-btn');
        const stopBtn = document.getElementById('stop-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
        const controlsContainer = document.getElementById('controls-container');
        const appContainer = document.getElementById('app-container');
        const statusEl = document.getElementById('status');
        const loaderContainer = document.getElementById('loader-container');
        const videoContainer = document.getElementById('video-container');

        // Zustand der App
        let isRecording = false;
        let recordedData = [];
        let pose;

        // Funktion zum Aktualisieren des Status
        function updateStatus(message, isRecordingStatus = false) {
            statusEl.innerHTML = isRecordingStatus 
                ? `<span class="dot mr-2"></span> ${message}`
                : message;
        }
        
        // NEU: Funktion zum Anpassen der Canvas-Größe
        function resizeCanvas() {
            const videoAspectRatio = videoElement.videoWidth / videoElement.videoHeight;
            const containerWidth = videoContainer.clientWidth;
            const containerHeight = videoContainer.clientHeight;
            const containerAspectRatio = containerWidth / containerHeight;

            let canvasWidth, canvasHeight;

            if (videoAspectRatio > containerAspectRatio) {
                canvasWidth = containerWidth;
                canvasHeight = containerWidth / videoAspectRatio;
            } else {
                canvasHeight = containerHeight;
                canvasWidth = containerHeight * videoAspectRatio;
            }

            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;

            const canvasStyle = canvasElement.style;
            canvasStyle.width = `${canvasWidth}px`;
            canvasStyle.height = `${canvasHeight}px`;
            canvasStyle.top = `${(containerHeight - canvasHeight) / 2}px`;
            canvasStyle.left = `${(containerWidth - canvasWidth) / 2}px`;
        }


        // Funktion wird aufgerufen, wenn das Pose-Modell Ergebnisse liefert
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#0ea5e9', lineWidth: 4 });
                drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#67e8f9', lineWidth: 2 });

                if (isRecording) {
                    const timestamp = performance.now();
                    recordedData.push({
                        timestamp: timestamp,
                        landmarks: results.poseLandmarks
                    });
                }
            }
            canvasCtx.restore();
        }

        // ZIP-Datei erstellen und herunterladen
        function createAndDownloadZip() {
            if (recordedData.length === 0) {
                updateStatus("Keine Daten zum Exportieren vorhanden.");
                return;
            }
            updateStatus("ZIP-Datei wird erstellt...");
            const zip = new JSZip();
            const jsonData = JSON.stringify(recordedData, null, 2);
            zip.file("motion_capture_data.json", jsonData);
            zip.generateAsync({ type: "blob" })
                .then(function(content) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    link.download = `motion_capture_${timestamp}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    updateStatus("Export erfolgreich! Bereit für die nächste Aufnahme.");
                });
        }

        // Initialisierung des Pose-Modells
        function initializePose() {
             pose = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            pose.onResults(onResults);
        }

        // Initialisierung der Kamera
        function initializeCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await pose.send({ image: videoElement });
                },
                width: 1280,
                height: 720
            });
            camera.start();
        }

        // --- Event-Listener ---
        recordBtn.addEventListener('click', () => {
            isRecording = true;
            recordedData = [];
            recordBtn.disabled = true;
            stopBtn.disabled = false;
            updateStatus("Aufnahme läuft...", true);
        });

        stopBtn.addEventListener('click', () => {
            isRecording = false;
            recordBtn.disabled = false;
            stopBtn.disabled = true;
            createAndDownloadZip();
        });

        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                appContainer.requestFullscreen().catch(err => {
                    console.error(`Fehler beim Umschalten in den Vollbildmodus: ${err.message} (${err.name})`);
                });
            }
        });

        exitFullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                exitFullscreenBtn.classList.remove('hidden');
                controlsContainer.classList.add('hidden');
            } else {
                exitFullscreenBtn.classList.add('hidden');
                controlsContainer.classList.remove('hidden');
            }
            // Größe nach Änderung des Vollbildstatus neu berechnen
            setTimeout(resizeCanvas, 100);
        });
        
        // NEU: Event-Listener für die Größenänderung des Fensters
        window.addEventListener('resize', resizeCanvas);

        // App starten
        async function main() {
            updateStatus("KI-Modell wird initialisiert...");
            initializePose();
            
            setTimeout(() => {
                updateStatus("Kamera wird gestartet...");
                initializeCamera();
                videoElement.addEventListener('loadeddata', () => {
                    loaderContainer.classList.add('hidden');
                    videoContainer.classList.remove('hidden');
                    
                    // NEU: Initiales Anpassen der Canvas-Größe
                    const videoAspectRatio = videoElement.videoWidth / videoElement.videoHeight;
                    videoContainer.style.aspectRatio = videoAspectRatio;
                    resizeCanvas();

                    updateStatus("Bereit! Drücke 'Aufnehmen', um zu starten.");
                });
            }, 1000);
        }

        main();

    </script>
</body>
</html>
